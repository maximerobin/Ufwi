#!/bin/sh
# File generated by EdenWall: {{ _generation_time_ }}
# 
# (C) 2008 by Pablo Neira Ayuso <pablo@netfilter.org>
# (C) 2009 EdenWall Technologies
#
# This software may be used and distributed according to the terms
# of the GNU General Public License, incorporated herein by reference.
#
# Description:
#
# This is the script for primary-backup setups for keepalived
# (http://www.keepalived.org). You may adapt it to make it work with other
# high-availability managers.
#
# Do not forget to include the required modifications to your keepalived.conf
# file to invoke this script during keepalived's state transitions.
#
# Contributions to improve this script are welcome :).
#

CONNTRACKD_BIN=/usr/sbin/conntrackd
CONNTRACKD_LOCK=/var/lock/conntrack.lock
CONNTRACKD_CONFIG=/etc/conntrackd/conntrackd.conf

CONNTRACKD_PREVIOUS_ACTION=/tmp/conntrackd_ha

. /etc/ha.d/resource.d/hto-mapfuncs

timeout()
{
    TIMEOUT=15

    PROCESS_TIMEDOUT=1

    log_and_print "Starting $@"
    "$@" &
    PROCESS_PID=$!

    for((i = 0 ; $i < $TIMEOUT ; i++))
    do  
        echo $i $PROCESS_PID
        if [ ! -e /proc/$PROCESS_PID ]
        then
            PROCESS_TIMEDOUT=0
            break
        fi
        sleep 1
    done
    
    if [ $PROCESS_TIMEDOUT = 0 ]
    then
        wait $PROCESS_PID
        PROCESS_TIMEDOUT=$?
        log_and_print "Exited with code $PROCESS_TIMEDOUT"
    else
        log_and_print "Command timedout after ${TIMEOUT}s : ($PROCESS_PID) $@"
        kill -9 $PROCESS_PID
    fi

    return $PROCESS_TIMEDOUT
}

case "$1" in
  start)
    echo 0 > ${CONNTRACKD_PREVIOUS_ACTION}
    # request resynchronization with active firewall replica (if any)
    # Note: this does nothing in the alarm approach.
    #
    timeout $CONNTRACKD_BIN -C $CONNTRACKD_CONFIG -n
    if [ $? -eq 1 ]
    then
        log_and_print "ERROR: failed to invoke conntrackd -n"
    fi

    #
    # commit the external cache into the kernel table
    #
    timeout $CONNTRACKD_BIN -C $CONNTRACKD_CONFIG -c
    if [ $? -eq 1 ]
    then
        log_and_print "ERROR: failed to invoke conntrackd -c"
    fi

    #
    # flush the internal and the external caches
    #
    timeout $CONNTRACKD_BIN -C $CONNTRACKD_CONFIG -f
    if [ $? -eq 1 ]
    then
        log_and_print "ERROR: failed to invoke conntrackd -f"
    fi

    #
    # resynchronize my internal cache to the kernel table
    #
    timeout $CONNTRACKD_BIN -C $CONNTRACKD_CONFIG -R
    if [ $? -eq 1 ]
    then
        log_and_print "ERROR: failed to invoke conntrackd -R"
    fi

    #
    # send a bulk update to backups 
    #
    timeout $CONNTRACKD_BIN -C $CONNTRACKD_CONFIG -B
    if [ $? -eq 1 ]
    then
        log_and_print "ERROR: failed to invoke conntrackd -B"
    fi
    ;;
  stop)
    echo 1 > ${CONNTRACKD_PREVIOUS_ACTION}
    # failure : send all conntrack entry before death
    # send a bulk update to backups 
    #
    timeout $CONNTRACKD_BIN -C $CONNTRACKD_CONFIG -B
    if [ $? -eq 1 ]
    then
        log_and_print "ERROR: failed to invoke conntrackd -B"
    fi

    #
    # is conntrackd running? request some statistics to check it
    #
    timeout $CONNTRACKD_BIN -C $CONNTRACKD_CONFIG -s
    if [ $? -eq 1 ]
    then
        #
        # something's wrong, do we have a lock file?
        #
        if [ -f $CONNTRACKD_LOCK ]
        then
            log_and_print "WARNING: conntrackd was not cleanly stopped."
            log_and_print "If you suspect that it has crashed:"
            log_and_print "1) Enable coredumps"
            log_and_print "2) Try to reproduce the problem"
            log_and_print "3) Post the coredump to netfilter-devel@vger.kernel.org"
            rm -f $CONNTRACKD_LOCK
        fi
        
        # don't assume that conntrackd is not running
        KILL_CONNTRACKD_CMD='kill -9 $(pidof conntrackd|grep -v $$)'
        log_and_print "Clean state, execute '${KILL_CONNTRACKD_CMD}'"
        eval ${KILL_CONNTRACKD_CMD}
        log_and_print "'${KILL_CONNTRACKD_CMD}' return '$?'"

        timeout $CONNTRACKD_BIN -C $CONNTRACKD_CONFIG -d
        if [ $? -eq 1 ]
        then
            log_and_print "ERROR: cannot launch conntrackd"
            exit 1
        fi
    fi
    #
    # shorten kernel conntrack timers to remove the zombie entries.
    #
    timeout $CONNTRACKD_BIN -C $CONNTRACKD_CONFIG -t
    if [ $? -eq 1 ]
    then
        log_and_print "ERROR: failed to invoke conntrackd -t"
    fi

    #
    # request resynchronization with master firewall replica (if any)
    # Note: this does nothing in the alarm approach.
    #
    timeout $CONNTRACKD_BIN -C $CONNTRACKD_CONFIG -n
    if [ $? -eq 1 ]
    then
        log_and_print "ERROR: failed to invoke conntrackd -n"
    fi
    ;;
  fault)
    #
    # shorten kernel conntrack timers to remove the zombie entries.
    #
    timeout $CONNTRACKD_BIN -C $CONNTRACKD_CONFIG -t
    if [ $? -eq 1 ]
    then
        log_and_print "ERROR: failed to invoke conntrackd -t"
    fi
    ;;
  status|monitor)
    if [ ! -e ${CONNTRACKD_PREVIOUS_ACTION} ]; then
        log_and_print "INFO:  stopped"
    else
        previous_action=`cat ${CONNTRACKD_PREVIOUS_ACTION}`
        if [ "$previous_action" = 0 ]; then
            log_and_print "INFO: conntrackd Running OK"
        else
            log_and_print "INFO: conntrackd Resource is stopped"
        fi
    fi
    exit 0
  ;;
  *)
    log_and_print "ERROR: unknown state transition '$1'"
    echo "Usage: primary-backup.sh {primary|backup|fault}"
    exit 1
    ;;
esac

exit 0
