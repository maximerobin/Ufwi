"""
Copyright (C) 2009-2011 EdenWall Technologies

This file is part of NuFirewall. 
 
 NuFirewall is free software: you can redistribute it and/or modify 
 it under the terms of the GNU General Public License as published by 
 the Free Software Foundation, version 3 of the License. 
 
 NuFirewall is distributed in the hope that it will be useful, 
 but WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 GNU General Public License for more details. 
 
 You should have received a copy of the GNU General Public License 
 along with NuFirewall.  If not, see <http://www.gnu.org/licenses/>
"""

from __future__ import with_statement
from datetime import datetime
from os.path import join as path_join, exists as path_exists
from os import rename, unlink
from shutil import copyfile
from twisted.internet.threads import deferToThread

from ufwi_rpcd.common.transaction import Transaction, executeTransactions
from ufwi_rpcd.backend.logger import Logger

from ufwi_ruleset.config import LOCAL_RULES_IPV4_DIR, LOCAL_RULES_IPV6_DIR, USE_IPV6
from ufwi_ruleset.version import VERSION

class WriteRules(Transaction, Logger):
    def __init__(self, table, name, rules, ipv6, logger):
        Transaction.__init__(self)
        Logger.__init__(self, table, parent=logger)
        self.rules = rules
        self.ipv6 = ipv6
        self.name = name

        filename = '%s-localfw_%s.rules' % (table, self.name)
        if self.ipv6:
            self.filename = path_join(LOCAL_RULES_IPV6_DIR, filename)
        else:
            self.filename = path_join(LOCAL_RULES_IPV4_DIR, filename)
        self.old_filename = None
        self.new_filename = None

    def save(self):
        self.debug("Save old local rules %s" % self.name)
        if path_exists(self.filename):
            self.old_filename = self.filename + '.old'
            copyfile(self.filename, self.old_filename)

    def writeFile(self, filename):
        with open(filename, 'w') as fd:
            print >>fd, "# File generated by localfw %s" % VERSION
            print >>fd, "# %s" % datetime.now()
            for rule in self.rules:
                print >>fd, rule.getIptable()

    def prepare(self):
        self.debug("Prepare the new local rules %s" % self.name)
        if self.rules:
            self.new_filename = self.filename + '.new'
            self.writeFile(self.new_filename)

    def apply(self):
        self.info("Apply the new local rules %s" % self.name)
        if self.new_filename:
            rename(self.new_filename, self.filename)
            self.new_filename = None
        else:
            if path_exists(self.filename):
                unlink(self.filename)

    def rollback(self):
        self.warning("ERROR! Restore the previous local rules %s" % self.name)
        if self.old_filename:
            rename(self.old_filename, self.filename)
            self.old_filename = None

    def cleanup(self):
        for filename in (self.old_filename, self.new_filename):
            if not filename:
                continue
            try:
                unlink(filename)
            except OSError:
                pass

def applyRulesThread(logger, rules_file):
    name = rules_file.name
    filter_ipv4 = WriteRules('filter', name, rules_file.ipv4_filter_rules, False, logger)
    mangle_ipv4 = WriteRules('mangle', name, rules_file.ipv4_mangle_rules, False, logger)
    nat_ipv4 = WriteRules('nat', name, rules_file.ipv4_nat_rules, False, logger)
    transactions = [filter_ipv4, mangle_ipv4, nat_ipv4]
    if USE_IPV6:
        filter_ipv6 = WriteRules('filter', name, rules_file.ipv6_filter_rules, True, logger)
        transactions.append(filter_ipv6)
        mangle_ipv6 = WriteRules('mangle', name, rules_file.ipv6_mangle_rules, True, logger)
        transactions.append(mangle_ipv6)
        nat_ipv6 = WriteRules('nat', name, rules_file.ipv6_nat_rules, True, logger)
        transactions.append(nat_ipv6)
    executeTransactions(logger, transactions)

def reapplyLastRuleset(unused, context, core):
    return core.callService(context, 'ufwi_ruleset', 'reapplyLastRuleset')

def applyRules(context, component, rules_file):
    component.critical("Apply local firewall rules")
    defer = deferToThread(applyRulesThread, component, rules_file)
    # FIXME: call to reapplyLastRuleset() should be included in
    # applyRulesThread() to ensure the production ruleset consistency (restore
    # old files on error)
    defer.addCallback(reapplyLastRuleset, context, component.core)
    return defer

